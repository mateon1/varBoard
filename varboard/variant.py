from __future__ import annotations

from typing import Iterator, Iterable, Optional

from .state import PositionBuilder, Position, Square, BoardAction, Move, Piece, Color, HandType, GameEndValue


def get_kingsq(pos: Position, my: Color) -> tuple[Square, Square]:
    my_ksq = None
    opp_ksq = None
    for sq, p in pos.pieces_iter():
        if p.ty == "K":
            if p.color == my:
                my_ksq = sq
            else:
                opp_ksq = sq
    assert my_ksq is not None
    assert opp_ksq is not None
    return my_ksq, opp_ksq


def fen_board(pos: Position) -> str:
    cnt = 0
    last = None
    out = ""
    for sq, p in pos.squares_iter():
        if last != sq.rank:
            if cnt:
                out += str(cnt)
                cnt = 0
            if last is not None:
                out += "/"
            last = sq.rank
        if p is None:
            cnt += 1
        else:
            if cnt:
                out += str(cnt)
                cnt = 0
            pst = str(p)
            assert len(pst) == 1, "Nonstandard length piece types not supported yet"
            out += pst
    if cnt:
        out += str(cnt)
        cnt = 0
    return out


def fen_color(pos: Position) -> str:
    return Color.from_ply(pos.ply).value


def fen_castle(pos: Position) -> str:
    rights: Optional[tuple[int, int]] = pos.get_extra("castle")
    if rights is None: return "-"
    wc, bc = rights
    return ("K" if wc&1 else "") + ("Q" if wc&2 else "") + ("k" if bc&1 else "") + ("q" if bc&2 else "") or "-"


def fen_ep(pos: Position) -> str:
    ep: Optional[Square] = pos.get_extra("ep")
    if ep is not None:
        return str(ep)
    else:
        return "-"

def fen_move(pos: Position) -> str:
    return str(pos.ply // 2 + 1)


class Variant:
    """
    This class is the base class for each game variant.
    A variant needs to implement a few methods necessary to implement the game, such as providing legal moves and deciding whether a game position is won or not.
    """

    def _is_pos_ended(self, pos: Position) -> bool:
        """
        Internal, abstract function. Implement on a variant to use the default game_value implementation.
        Do not rely on this externally.
        """
        raise TypeError("Called _is_pos_ended on Variant base type")

    def _pos_value(self, pos: Position) -> GameEndValue:
        """
        Internal, abstract function. Implement on a variant to use the default game_value implementation.
        Do not rely on this externally.
        """
        raise TypeError("Called _pos_value on Variant base type")

    def uci_name(self) -> str:
        """
        Returns the UCI_Variant name for this variant.
        """
        raise TypeError("Called uci_name on Variant base type")

    def startpos(self) -> Position:
        """
        Returns the starting position for this variant.
        """
        raise TypeError("Called startpos on Variant base type")

    def pos_to_fen(self, pos: Position) -> str:
        """
        Returns the FEN representation of the given position, according to current variant.
        """
        return f"{fen_board(pos)} {fen_color(pos)} 0 {fen_move(pos)}"

    def game_value(self, startpos: Position, moves: Iterable[Move]) -> Optional[GameEndValue]:
        """
        Calculates the game's value, if finished, otherwise returns None.
        Prefer to pass a starting position and move sequence to allow implementing rules like three-fold repetition.
        """
        pos = startpos
        for m in moves:
            pos, _ = self.execute_move(pos, m)
        if not self._is_pos_ended(pos):
            return None
        return self._pos_value(pos)

    def legal_moves(self, pos: Position) -> Iterator[Move]:
        """
        Generates a list of legal moves from a given position.

        Implementations of this function should ensure they do not return duplicate moves, and if is_legal is overridden for performance, its results should exactly match the moves generated by this function.
        """
        raise TypeError("Called legal_moves on Variant base type")

    def is_legal(self, pos: Position, move: Move) -> bool:
        """
        Returns whether a move is legal in a given position or not.
        """
        for m in self.legal_moves(pos):
            if m == move: return True
        return False

    def execute_move(self, pos: Position, move: Move) -> tuple[Position, list[BoardAction]]:
        """
        Performs a move. Returns the new position and a list of primitive board actions the move consists of.
        Note that the board actions do not necessarily contain all information about the move, usually that reflected in the Position's extra information.
        The default implementation tries its best to interpret the move without variant-specific knowledge, this is okay for a lot of moves, but may be wrong if moves have extra effects, like castling, setting en-passant state, etc.
        """
        nextpos = PositionBuilder.from_position(pos)
        nextpos.ply(pos.ply + 1)
        color = Color.from_ply(pos.ply)
        actions = []

        if move.fromsq is None and move.intopiece is not None:
            hand: Optional[HandType] = pos.get_extra("hand")
            # If we're tracking pieces held in hand, remove the one we just dropped
            if hand is not None:
                whand, bhand = hand
                if color == Color.WHITE:
                    idx = whand.index(move.intopiece)
                    whand = whand[:idx] + whand[idx + 1:]
                else:
                    idx = bhand.index(move.intopiece)
                    bhand = bhand[:idx] + bhand[idx + 1:]
                hand = whand, bhand
                nextpos.extra("hand", hand)

        if move.fromsq is not None:
            nextpos.piece(move.fromsq, None)

        if move.tosq is not None:
            if pos.get_piece(move.tosq) is not None:
                nextpos.extra("lastcapture", pos.ply)
            if move.fromsq is None:
                nextpos.piece(move.tosq, move.intopiece)
                actions.append(BoardAction(move.tosq, move.intopiece))
            else:
                nextpos.piece(move.tosq, move.intopiece or pos.get_piece(move.fromsq))
                actions.append(BoardAction(move.tosq, move.fromsq))
                if move.intopiece is not None:
                    actions.append(BoardAction(move.tosq, move.intopiece))

        return nextpos.build(), actions

    def piece_legal_moves(self, pos: Position, fromsq: Square) -> Iterator[Move]:
        """
        Convenience function, returns legal moves involving a given piece (square).
        """
        for move in self.legal_moves(pos):
            if move.fromsq == fromsq:
                yield move

    def legal_drops(self, pos: Position, piecetype: Optional[Piece] = None) -> Iterator[Move]:
        """
        Convenience function, returns legal drop moves (potentially limited to a certain piece type).
        """
        for move in self.legal_moves(pos):
            if move.fromsq == None and (piecetype is None or piecetype == move.intopiece):
                yield move


class TicTacToe(Variant):
    def uci_name(self) -> str:
        return "tictactoe"

    @staticmethod
    def lines(pos: Position) -> Iterator[list[Optional[Piece]]]:
        """
        Helper, returns all lines on the board
        """
        size = len(pos.board)
        assert len(pos.board[0]) == size, "Square boards only"
        for row in pos.board:
            yield list(row)
        for col in range(size):
            yield [row[col] for row in pos.board]
        yield [pos.board[i][i] for i in range(size)]
        yield [pos.board[i][~i] for i in range(size)]

    def startpos(self) -> Position:
        return PositionBuilder((3, 3), 0).build()

    def _is_pos_ended(self, pos: Position) -> bool:
        if all(p is not None for sq, p in pos.squares_iter()):
            return True
        for line in self.lines(pos):
            if any(p is None for p in line):
                continue
            colors = [p.color for p in line if p is not None]
            if len(set(colors)) == 1:
                return True
        return False

    def _pos_value(self, pos: Position) -> GameEndValue:
        for line in self.lines(pos):
            if any(p is None for p in line):
                continue
            colors = [p.color for p in line if p is not None]
            if len(set(colors)) == 1:
                return GameEndValue.win_for(colors[0])
        return GameEndValue.DRAW

    def legal_moves(self, pos: Position) -> Iterator[Move]:
        color = Color.from_ply(pos.ply)
        piece = Piece("P", color)
        for sq, p in pos.squares_iter():
            if p is None:
                yield Move.drop_at(sq, piece)


class Chess(Variant):
    CASTLE_SHORT = 1
    CASTLE_LONG = 2

    def uci_name(self) -> str:
        return "chess"

    def startpos(self) -> Position:
        b = PositionBuilder((8, 8), 0)
        for x, p in enumerate("RNBQKBNR"):
            b.piece(Square(file=x, rank=0), Piece(p, Color.WHITE))
            b.piece(Square(file=x, rank=7), Piece(p, Color.BLACK))
            b.piece(Square(file=x, rank=1), Piece("P", Color.WHITE))
            b.piece(Square(file=x, rank=6), Piece("P", Color.BLACK))
        b.extra("castle", (3, 3))
        b.extra("ep", None)
        return b.build()

    def pos_to_fen(self, pos: Position) -> str:
        # TODO: Implement 50mr counter
        return f"{fen_board(pos)} {fen_color(pos)} {fen_castle(pos)} {fen_ep(pos)} 0 {fen_move(pos)}"

    def can_move(self, piece: Piece, like: str) -> bool:
        assert like.upper() == like
        if like in "PNKQ":
            return piece.ty == like
        if like == "B":
            return piece.ty in "QB"
        if like == "R":
            return piece.ty in "QR"
        raise ValueError(f"Don't know whether {piece.ty} moves like {like}")

    def target_squares(self, pos: Position, square: Square, attack: bool = False) -> Iterator[Square]:
        piece = pos.get_piece(square)
        if piece is None: return
        my = piece.color
        relrank = pos.bounds()[1] - 1 - square.rank if my == Color.BLACK else square.rank
        forwardy = 1 if my == Color.WHITE else -1
        W = len(pos.board[0])
        H = len(pos.board)
        ox, oy = square.to_tuple()

        if piece.ty == "P":
            upsq = square.offset(0, forwardy)
            assert pos.inbounds(upsq)
            if pos.get_piece(upsq) is None and not attack:
                yield upsq
                _, height = pos.bounds()
                up2sq = square.offset(0, 2 * forwardy)
                if relrank == 1 and pos.get_piece(up2sq) is None:
                    yield up2sq
            if ox > 0:
                sq = upsq.offset(-1, 0)
                p = pos.get_piece(sq)
                if p is not None and p.color == ~my or attack:
                    yield sq
                elif pos.get_extra("ep") == sq:
                    yield sq
            if ox < W - 1:
                sq = upsq.offset(1, 0)
                p = pos.get_piece(sq)
                if p is not None and p.color == ~my or attack:
                    yield sq
                elif pos.get_extra("ep") == sq:
                    yield sq
            return  # early return, do not handle pawn-like variant pieces
        if self.can_move(piece, "N"):
            for m in range(8):
                x, y = 1, 2
                if m & 1: x, y = y, x
                if m & 2: x = -x
                if m & 4: y = -y
                sq = square.offset(x, y)
                if 0 <= ox + x < W and 0 <= oy + y < H:
                    p = pos.get_piece(sq)
                    if p is None or p.color == ~my:
                        yield sq
        if self.can_move(piece, "K"):
            for x in {-1, 0, 1}:
                for y in {-1, 0, 1}:
                    sq = square.offset(x, y)
                    if not pos.inbounds(sq): continue
                    p = pos.get_piece(sq)
                    if p is None or p.color == ~my:
                        yield sq
            # NOTE: Castling is complex, but cannot capture pieces, handle separately when generating legal moves
        rays = []
        if self.can_move(piece, "B"):
            for y in {-1, 1}:
                for x in {-1, 1}:
                    rays.append((x, y))
        if self.can_move(piece, "R"):
            for y in {-1, 1}: rays.append((0, y))
            for x in {-1, 1}: rays.append((x, 0))
        for x, y in rays:
            cur = square
            while True:
                cur = cur.offset(x, y)
                if not pos.inbounds(cur): break
                p = pos.get_piece(cur)
                if p is None:
                    yield cur
                else:
                    if p.color == ~my:
                        yield cur
                    break

    def game_value(self, startpos: Position, moves: Iterable[Move]) -> Optional[GameEndValue]:
        # TODO: Check 50mr, draw
        # TODO: Check 3fr, draw
        positions = [startpos]
        for m in moves:
            p, _ = self.execute_move(positions[-1], m)
            positions.append(p)
        pos = positions[-1]
        for m in self.legal_moves(pos):
            break
        else:
            # no legal moves
            if self.is_in_check(pos, Color.from_ply(pos.ply)):  # Checkmate
                return GameEndValue.win_for(~Color.from_ply(pos.ply))
            else:  # Stalemate
                return GameEndValue.DRAW

        # Insufficient material check
        wmaterial = sorted([p.ty for _, p in pos.pieces_iter(Color.WHITE)])
        bmaterial = sorted([p.ty for _, p in pos.pieces_iter(Color.BLACK)])

        if len(wmaterial) == 1 or len(bmaterial) == 1:
            omaterial = wmaterial if len(wmaterial) > 1 else bmaterial
            if len(omaterial) == 1:
                return GameEndValue.DRAW
            if len(omaterial) == 2 and set(omaterial) == {"K", "B"}:
                return GameEndValue.DRAW
            if len(omaterial) == 2 and set(omaterial) == {"K", "N"}:
                return GameEndValue.DRAW

        return None

    def is_in_check(self, pos: Position, color: Color) -> bool:
        for sq, _ in pos.pieces_iter(~color):
            for tsq in self.target_squares(pos, sq):
                p = pos.get_piece(tsq)
                if p is not None and p.color == color and p.ty == "K":
                    return True
        return False

    def legal_moves(self, pos: Position) -> Iterator[Move]:
        # NOTE: Only supports 8x8 boards, smaller and larger variants should reimplement
        my = Color.from_ply(pos.ply)
        rights = pos.get_extra("castle") or (0, 0)
        myrights = rights[0] if my == Color.WHITE else rights[1]
        homerank = 0 if my == Color.WHITE else 7

        pieces = []
        opppieces = []
        attackedsq: set[Square] = set()
        for sq, p in pos.pieces_iter():
            if p.color == my:
                pieces.append((sq, p))
            else:
                opppieces.append((sq, p))

        incheck = self.is_in_check(pos, my)

        for sq, p in opppieces:
            for tsq in self.target_squares(pos, sq, attack=True):
                attackedsq.add(tsq)

        for sq, p in pieces:
            for tsq in self.target_squares(pos, sq):
                # Does move lead to our king being threatened?
                probepos, _ = self.execute_move(pos, Move.move(sq, tsq))
                if self.is_in_check(probepos, my):
                    continue  # if so, prune the move

                # handle promotion case
                if p.ty == "P" and tsq.rank in {0, 7}:
                    for ty in "QNRB":
                        yield Move.move_promote(sq, tsq, Piece(ty, my))
                else:
                    yield Move.move(sq, tsq)

        if myrights & Chess.CASTLE_SHORT:
            move = Move.move(Square(rank=homerank, file=4), Square(rank=homerank, file=6))
            rookfrom = Square(rank=move.tosq.rank, file=7)
            rookto = move.tosq.offset(-1, 0)
            rook = pos.get_piece(rookfrom)
            assert rook is not None
            for i in {4, 5, 6, 7}:
                if Square(rank=homerank, file=i) in attackedsq:
                    break
            else:
                yield move
        if myrights & Chess.CASTLE_LONG:
            move = Move.move(Square(rank=homerank, file=4), Square(rank=homerank, file=2))
            rookfrom = Square(rank=move.tosq.rank, file=0)
            rookto = move.tosq.offset(-1, 0)
            rook = pos.get_piece(rookfrom)
            assert rook is not None
            for i in {0, 1, 2, 3, 4}:
                if Square(rank=homerank, file=i) in attackedsq:
                    break
            else:
                yield move

    def execute_move(self, pos: Position, move: Move) -> tuple[Position, list[BoardAction]]:
        # TODO: 50mr counters
        maybepos, actions = super().execute_move(pos, move)
        nextpos = PositionBuilder.from_position(maybepos).extra("ep", None)  # Lose en passant rights
        if move.fromsq is not None:
            fromsq = move.fromsq
        else:  # piece drop or null move, let the generic impl handle it
            return nextpos.build(), actions
        piece = pos.get_piece(fromsq)
        assert piece is not None
        if piece.ty in "NBQ":  # "simple" piece type
            return nextpos.build(), actions
        my = piece.color
        forwardy = 1 if my == Color.WHITE else -1
        homerank = 0 if my == Color.WHITE else 7
        if piece.ty == "P":
            ep = pos.get_extra("ep")
            if ep is not None and move.tosq == ep:
                capturesq = move.tosq.offset(0, -forwardy)
                nextpos.piece(capturesq, None)
                actions.append(BoardAction(capturesq, None))
            elif move.tosq == fromsq.offset(0, 2 * forwardy):
                sq = move.tosq.offset(-1, 0)
                if pos.inbounds(sq):
                    p = pos.get_piece(sq)
                    if p is not None and p.color == ~my and p.ty == "P":
                        nextpos.extra("ep", move.tosq.offset(0, -forwardy))
                sq = move.tosq.offset(1, 0)
                if pos.inbounds(sq):
                    p = pos.get_piece(move.tosq.offset(1, 0))
                    if p is not None and p.color == ~my and p.ty == "P":
                        nextpos.extra("ep", move.tosq.offset(0, -forwardy))

            return nextpos.build(), actions
        castlew: int
        castleb: int
        castlew, castleb = pos.get_extra("castle") or (3, 3)
        mycastle = castlew if my == Color.WHITE else castleb
        if piece.ty == "K":
            if fromsq.rank == homerank and move.tosq.rank == homerank and abs(move.fromsq.file - move.tosq.file) > 1:
                # TODO: Add validity checking?
                if move.tosq.file == 2:
                    # Queenside
                    rookfrom = Square(rank=move.tosq.rank, file=0)
                    rookto = move.tosq.offset(1, 0)
                else:
                    # Kingside
                    rookfrom = Square(rank=move.tosq.rank, file=7)
                    rookto = move.tosq.offset(-1, 0)
                rook = pos.get_piece(rookfrom)
                assert rook is not None
                nextpos.piece(rookfrom, None)
                nextpos.piece(rookto, rook)
                actions.append(BoardAction(rookto, rookfrom))
            if my == Color.WHITE:
                castlew = 0
            else:
                castleb = 0
            nextpos.extra("castle", (castlew, castleb))
            return nextpos.build(), actions
        if piece.ty == "R":
            if fromsq.rank == homerank and fromsq.file in {0, 7}:  # TODO: Chess960
                if my == Color.WHITE:
                    castlew &= ~(Chess.CASTLE_LONG if fromsq.file == 0 else Chess.CASTLE_SHORT)
                else:
                    castleb &= ~(Chess.CASTLE_LONG if fromsq.file == 0 else Chess.CASTLE_SHORT)
                nextpos.extra("castle", (castlew, castleb))
            return nextpos.build(), actions
        raise ValueError(f"Bad piece {piece!r}")


class NoCastleChess(Chess):
    def uci_name(self) -> str:
        return "nocastle"

    def startpos(self) -> Position:
        b = PositionBuilder((8, 8), 0)
        for x, p in enumerate("RNBQKBNR"):
            b.piece(Square(file=x, rank=0), Piece(p, Color.WHITE))
            b.piece(Square(file=x, rank=7), Piece(p, Color.BLACK))
            b.piece(Square(file=x, rank=1), Piece("P", Color.WHITE))
            b.piece(Square(file=x, rank=6), Piece("P", Color.BLACK))
        b.extra("ep", None)
        return b.build()


class PawnsOnly(Chess):
    def uci_name(self) -> str:
        return "pawnsonly"

    def startpos(self) -> Position:
        b = PositionBuilder((8, 8), 0)
        for file in range(8):
            b.piece(Square(file=file, rank=1), Piece("P", Color.WHITE))
            b.piece(Square(file=file, rank=6), Piece("P", Color.BLACK))
        b.extra("ep", None)
        return b.build()

    def game_value(self, startpos: Position, moves: Iterable[Move]) -> Optional[GameEndValue]:
        positions = [startpos]
        for m in moves:
            p, _ = self.execute_move(positions[-1], m)
            positions.append(p)
        pos = positions[-1]
        for sq, p in pos.pieces_iter():
            if sq.rank in {0,7}:
                return GameEndValue.win_for(p.color)

        return None

class RacingKings(Chess):
    def uci_name(self) -> str:
        return "racingkings"

    def startpos(self) -> Position:
        b = PositionBuilder((8, 8), 0)
        for x, p in enumerate("xRBN"):
            for rank in range(2):
                ty = p
                if ty == "x":
                    ty = "QK"[rank]
                b.piece(Square(file=7 - x, rank=rank), Piece(ty, Color.WHITE))
                b.piece(Square(file=x, rank=rank), Piece(ty, Color.BLACK))
        b.extra("castle", (0, 0))
        b.extra("ep", None)
        return b.build()

    def game_value(self, startpos: Position, moves: Iterable[Move]) -> Optional[GameEndValue]:
        positions = [startpos]
        for m in moves:
            p, _ = self.execute_move(positions[-1], m)
            positions.append(p)
        pos = positions[-1]
        my = Color.from_ply(pos.ply)
        my_ksq, opp_ksq = get_kingsq(pos, my)

        if my_ksq.rank == 7 and opp_ksq.rank == 7:
            return GameEndValue.DRAW

        if my_ksq.rank == 7:
            return GameEndValue.win_for(my)

        if opp_ksq.rank == 7 and my_ksq.rank < 6:  # If we're one tile behind we can still force a draw
            return GameEndValue.win_for(~my)

        if opp_ksq.rank == 7 and my_ksq.rank == 6:  # But sometimes we can't force a draw if no king moves to the last rank are available
            for m in self.legal_moves(pos):
                if m.fromsq == my_ksq and m.tosq.rank == 7:
                    return None
            return GameEndValue.win_for(~my)

        return None

    def legal_moves(self, pos: Position) -> Iterator[Move]:
        my = Color.from_ply(pos.ply)
        my_ksq, opp_ksq = get_kingsq(pos, my)
        assert my_ksq is not None
        assert opp_ksq is not None
        if my_ksq.rank == 7: return
        if opp_ksq.rank == 7 and my_ksq.rank < 6: return

        for m in super().legal_moves(pos):
            # Does move lead to checking other king?
            probepos, _ = self.execute_move(pos, m)
            if self.is_in_check(probepos, ~my):
                continue  # if so, prune the move
            yield m
